#!/usr/bin/env python3

import sys, getopt
import operator
import os.path
import os
import operator
import pefile
import hashlib
import json

inputfile = ''
matches = []
flat_list = ''
rulelist = []
for _ in os.listdir("rules"):
	rulelist.append(_)
data = dict()


class ExtractFeatures():

    # Defining init method taking parameter file.
    def __init__(self, file):
        self.file = file

    # Method for extracting the MD5 hash of a file.
    # It is not always possible to fit the entire file into memory so chunks of
    # 4096 bytes are read and sequentially fed into the function.
    def get_md5(self, file):
        md5 = hashlib.md5()
        with open(file, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                md5.update(chunk)
            return md5.hexdigest()


    # Method for extracting all features from an input file.
    def get_fileinfo(self, file):
        # Creates a dictionary that will hold feature names as keys and 
        # their feature values as values.
        features = {}

        # Assigns pe to the input file. fast_load loads all directory 
        # information.
        pe = pefile.PE(file, fast_load=True)

        # CPU that the file is intended for.
        features['Machine'] = pe.FILE_HEADER.Machine

        # DebugSize is the size of the debug directory table. Clean files
        # typically have a debug directory and thus, will have a non-zero
        # values.
        features['DebugSize'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[6].Size

        # Debug Relative Virtual Address (RVA). 
        features['DebugRVA'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[6].\
            VirtualAddress

        # MajorImageVersion is the version of the file. This is user defined
        # and for clean programs is often populated. Malware often has a
        # value of 0 for this.
        features['MajorImageVersion'] = pe.OPTIONAL_HEADER.MajorImageVersion

        # MajorOSVersion is the major operating system required to run exe.
        features['MajorOSVersion'] = pe.OPTIONAL_HEADER.\
            MajorOperatingSystemVersion

        # Export Relative Virtual Address (VRA).
        features['ExportRVA'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[0].\
            VirtualAddress

        # ExportSize is the size of the export table. Usually non-zero for
        # clean files.
        features['ExportSize'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[0].Size

        # IatRVA is the relative virtual address of import address
        # table. Clean files typically have 4096 for this where as malware
        # often has 0 or a very large number.
        features['IatVRA'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[12].\
            VirtualAddress

        # ResourcesSize is the size of resources section of PE header. 
        # Malware sometimes has 0 resources.
        features['MajorLinkerVersion'] = pe.OPTIONAL_HEADER.\
            MajorLinkerVersion

        # MinorLinkerVersion is the minor version linker that produced the
        # file.
        features['MinorLinkerVersion'] = pe.OPTIONAL_HEADER.MinorLinkerVersion

        # NumberOfSections is the number of sections in file.
        features['NumberOfSections'] = pe.FILE_HEADER.NumberOfSections 

        # SizeOfStackReserve denotes the amount of virtual memory to reserve
        # for the initial thread's stack.
        features['SizeOfStackReserve'] = pe.OPTIONAL_HEADER.SizeOfStackReserve

        # DllCharacteristics is a set of flags indicating under which
        # circumstances a DLL's initialization function will be called.
        features['DllCharacteristics'] = pe.OPTIONAL_HEADER.DllCharacteristics

        # ResourceSize denotes the size of the resources section.
        # Malware may often have no resources but clean files will.
        features['ResourceSize'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[2].Size

        return features

def scanning(rulef):
    import yara
    global inputfile
    fh = open("rules/"+rulef, 'rb')
    rule = yara.compile(file=fh)
    fh.close()
    cache = rule.match(inputfile, timeout=60)
    if cache:
        if 'Rule to' not in cache[0].meta['description']: 
            matches.append(cache[0].meta['description'])
    if matches:
        return matches
    else:
        return 0

def adjust():
	from pathlib import Path, PureWindowsPath
	global inputfile
	inputfile = inputfile.replace('\\',"//")

def malwarescanner(argv):
	global inputfile,matches
	matches = []
	inputfile = argv
	adjust()
	for x in rulelist:
		scanning(x)
	get_features = ExtractFeatures(inputfile)
	data = get_features.get_fileinfo(inputfile)
	md5 = ExtractFeatures(inputfile)
	md5_hash = md5.get_md5(inputfile)
	#print("[*] Printing extracted file features...")
	#print("\n\tMD5: ", md5_hash)
	#print("\tDebug Size: ", data['DebugSize'])
	#print("\tDebug RVA: ", data['DebugRVA'])
	#print("\tMajor Image Version:", data['MajorImageVersion'])
	#print("\tMajor OS Version:", data['MajorOSVersion'])
	#print("\tExport RVA:", data['ExportRVA'])
	#print("\tExport Size:", data['ExportSize'])
	#print("\tIat RVA: ", data['IatVRA'])
	#print("\tMajor Linker Version: ", data['MajorLinkerVersion'])
	#print("\tMinor Linker Version", data['MinorLinkerVersion'])
	#print("\tNumber Of Sections: ", data['NumberOfSections'])
	#print("\tSize Of Stack Reserve: ", data['SizeOfStackReserve'])
	#print("\tDll Characteristics: ", data['DllCharacteristics'])
	#print("\tResource Size: ", data['ResourceSize'])
	#matches = reduce(operator.concat, matches)
	#print("\n\n[*] Following behaviours were detected in given file: \n")
	#for _ in matches:
	#	print('\t'+_)
	if matches:
		verdict = 'Malicious'
	else:
		verdict = 'Benign'
	data.update({'Behaviour': matches, 'MD5': md5_hash, 'Verdict': verdict})
	#print(data)
	return json.dumps(data)

